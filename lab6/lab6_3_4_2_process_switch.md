#### 进程切换过程

进程调度函数 schedule 选择了下一个将占用 CPU 执行的进程后，将调用进程切换，从而让新的进程得以执行。通过实验四和实验五的理解，应该已经对进程调度和上下文切换有了初步的认识。在实验五中，结合调度器框架的设计，可对 ucore 中的进程切换以及堆栈的维护和使用等有更加深刻的认识。假定有两个用户进程，在二者进行进程切换的过程中，具体的步骤如下：

首先在执行某进程 A 的用户代码时，出现了一个 trap (例如是一个外设产生的中断)，这个时候就会从进程 A 的用户态切换到内核态(过程(1))，并且保存好进程 A 的 trapframe；当内核态处理中断时发现需要进行进程切换时，ucore 要通过 schedule 函数选择下一个将占用 CPU 执行的进程（即进程 B），然后会调用 proc_run 函数，proc_run 函数进一步调用 switch_to 函数，切换到进程 B 的内核态(过程(2))，继续进程 B 上一次在内核态的操作，并通过 iret 指令，最终将执行权转交给进程 B 的用户空间(过程(3))。

当进程 B 由于某种原因发生中断之后(过程(4))，会从进程 B 的用户态切换到内核态，并且保存好进程 B 的 trapframe；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程 A，ucore 再次切换到进程 A(过程(5))，会执行进程 A 上一次在内核调用 schedule (具体还要跟踪到 switch_to 函数)函数返回后的下一行代码，这行代码当然还是在进程 A 的上一次中断处理流程中。最后当进程 A 的中断处理完毕的时候，执行权又会反交给进程 A 的用户代码(过程(6))。这就是在只有两个进程的情况下，进程切换间的大体流程。

几点需要强调的是：

**a)**
需要透彻理解在进程切换以后，程序是从哪里开始执行的？需要注意到虽然指令还是同一个 cpu 上执行，但是此时已经是另外一个进程在执行了，且使用的资源已经完全不同了。

**b)**
内核在第一个程序运行的时候，需要进行哪些操作？有了实验四和实验五的经验，可以确定，内核启动第一个用户进程的过程，实际上是从进程启动时的内核状态切换到该用户进程的内核状态的过程，而且该用户进程在用户态的起始入口应该是 forkret。
